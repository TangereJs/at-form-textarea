<link rel="import" href="../tangere/Tangere.html">
<link rel="import" href="../at-i18n/at-i18n-behavior.html">
<link rel="import" href="../at-theme/at-theme.html">
<link rel="import" href="../at-core-resize-sensor/at-core-resize-sensor.html">
<link rel="import" href="../at-form-behaviors/at-form-behaviors-validation.html">
<link rel="import" href="../iron-label/iron-label.html">

<dom-module id="at-form-textarea">
  <template>
    <style include="at-form-common"></style>
    <style>
      :host * {
        box-sizing: border-box;
      }

      :host {
        @apply(--at-form-host);
      }

      #hint {
        min-height: 14px;
        margin-bottom: 8px;
      }
    </style>
    <div id="atContainer" class="at-container">
      <at-core-resize-sensor id="resizeSensor"></at-core-resize-sensor>
      <div class="clear-float"></div>
      <div>
        <iron-label id="label" for="valueProvider">{{label}}</iron-label>
        <div id="contentContainer" class="at-content-container">
          <textarea id="valueProvider" rows="3" class="at-content has-placeholder"></textarea>
        </div>
        <div id="hint"></div>
      </div>
    </div>
  </template>
  <script>
    'use strict';
    Polymer({
      is: 'at-form-textarea',
      behaviors: [ Tangere.behaviors.formValidation, Tangere.behaviors.i18n ],
      properties: {
        label: {
          type: String,
          value: ''
        },
        value: {
          type: String,
          value: '',
          // notify: true,
          observer: 'valueChanged',
          xtype: 'textarea'
        },
        disabled: {
          type: Boolean,
          value: false,
          observer: 'disabledChanged'
        },
        required: {
          type: Boolean,
          value: false,
          observer: 'requiredChanged'
        },
        /**
         * if maxchars == 0 no check should be done,
         * if != 0 total chars can't be longer then maxchars
         */
        maxChars: {
          type: Number,
          value: 0,
          observer: 'maxCharsChanged'
        },
        /**
         * if maxlines == 0 the textarea should autogrow
         * if maxlines != 0 the textarea should be rendered with the fixed number of lines
         */
        maxLines: {
          type: Number,
          value: 0,
          observer: 'maxLinesChanged'
        },
        autogrowLineLimit: {
          type: Number,
          value: 6,
          observer: 'autogrowLineLimitChanged'
        },
        hideLabel: {
          type: Boolean,
          value: false,
          observer: 'hideLabelChanged'
        },
        /**
         * Hides the element. When hidden nothing is displayed for the element
         * @property hide
         * @type Boolean
         * @default false
         */
        hide: {
          type: Boolean,
          value: false,
          observer: 'hideChanged'
        },
      },
      $meta: [{
        title: "Textarea",
        type: "string",
        xtype: "textarea"
      }],
      _errorMessage: '',
      _errorMessageTemplates: {
        maxCharsHint: "You can not enter more than {maxChars} characters.",
        maxLinesHint: "You can not enter more than {maxLines} lines of text."
      },

      _errorMessageIds: {
        maxChars: "maxChars",
        maxLines: "maxLines"
      },
      _isReady: false,
      hideChanged: function(newValue, oldValue) {
        var wrapper = this.$.atContainer;
        this.toggleClass('hidden', newValue, wrapper);
        if (!newValue) {
          this._updateAutoGrow();
        }

        if (this._isReady) {
          this.validate();
        }
      },
      hideLabelChanged: function(newValue, oldValue) {
        this.toggleClass('hidden', newValue, this.$.label);
      },
      attached: function() {
        var self = this;
        this.$.resizeSensor.addEventListener('resize-sensed', function() {
          self._updateAutoGrow();
        });
      },
      ready: function() {

        this._errorMessageTemplates.maxCharsHint = this.T(this._errorMessageTemplates.maxCharsHint);
        this._errorMessageTemplates.maxLinesHint = this.T(this._errorMessageTemplates.maxLinesHint);

        // *ij* part of validation behavior API
        // add custom validation functions to _validationFunctions array in validation behavior
        this._validationFunctions.push(this._validateMaxChars.bind(this));
        this._validationFunctions.push(this._validateMaxLines.bind(this));

        var valueProvider = this.$.valueProvider;
        var self = this;
        valueProvider.addEventListener('change', function(event) {
          event.stopPropagation();
          self._updateAutoGrow();
          self.value = valueProvider.value;
          self.validate();
          self.fire('value-changed', {
            value: self.value
          });
        });

        valueProvider.addEventListener('blur', function(event) {
          event.stopPropagation();
          //   self.value = valueProvider.value;
          self.validate();
          //   self.fire('value-changed', { value: self.value });
        });

        valueProvider.addEventListener('input', function(event) {
          event.stopPropagation();
          self._updateAutoGrow();
        });

        this._isReady = true;
      },
      focus: function() {
        this.$.valueProvider.focus();
      },
      _updateAutoGrow: function() {
        var self = this;
        try {
          var autogrowLineLimit = parseInt(self.autogrowLineLimit);
          if (autogrowLineLimit === 0) {
            self._autoGrowHelper();
          } else {
            var valueProvider = this.$.valueProvider;
            var lineCount = this._getLineCount(valueProvider.value);
            if (lineCount > this.autogrowLineLimit) {
              valueProvider.style['overflow-y'] = "scroll";
            } else {
              valueProvider.style['overflow-y'] = "hidden";
            }
          }
        } catch (e) {
          console.log(e);
        }
      },
      valueChanged: function(newValue, oldValue) {
        var valueProvider = this.$.valueProvider;
        valueProvider.value = newValue;
        this._updateAutoGrow();
        if (this._isReady) {
          this.validate();
        }
      },
      maxCharsChanged: function(newValue, oldValue) {
        if (this._isReady) {
          this.validate();
        }
      },
      maxLinesChanged: function(newValue, oldValue) {
        if (this._isReady) {
          this.validate();
        }
      },
      autogrowLineLimitChanged: function (newValue, oldValue) {
        var valueProvider = this.$.valueProvider;

        try {
          newValue = parseInt(newValue);
        } catch (e) {
          console.log(e);
          return;
        }

        if (newValue === 0) {
          if (valueProvider.scrollHeight > 14) {
            // handle autogrow here
            this._autoGrowHelper();
          }
          valueProvider.style['overflow-y'] = "hidden";
        } else if (newValue > 0) {
          valueProvider.style.height = 'auto';
          // *ij* read #743 on adenin.axosoft.com
          valueProvider.rows = newValue;
          var lineCount = this._getLineCount(this.value);
          if (lineCount > newValue) {
            valueProvider.style['overflow-y'] = "scroll";
          } else {
            valueProvider.style['overflow-y'] = "hidden";
          }
        }
      },
      _autoGrowHelper: function() {
        var valueProvider = this.$.valueProvider;
        if (valueProvider.scrollHeight > 0) {
          valueProvider.style.height = 'auto';
          valueProvider.style.height = (valueProvider.scrollHeight + 3) + 'px';
        }
      },
      disabledChanged: function(newValue, oldValue) {

        var atContainer = this.$.atContainer;
        this.toggleClass('disabled', newValue, atContainer);
        this.$.valueProvider.disabled = Boolean(newValue);

        if (this._isReady) {
          this.validate();
        }
      },
      requiredChanged: function(newValue, oldValue) {
        if (this._isReady) {
          this.validate();
        }
      },
      // *ij* part of validation behavior API
      // include _updateUIValidState function and implement it to update
      // the UI to reflect the new valid state
      _updateUIValidState: function(isValid) {
        var label = this.$.label;
        this.toggleClass('error', !isValid, label);
        var contentContainer = this.$.contentContainer;
        this.toggleClass('error', !isValid, contentContainer);
      },
      // *ij* part of validation behavior API
      // this is a custom validation function which checks the max chars constraint
      _validateMaxChars: function(value) {
        var valid = true;

        try {
          var maxChars = parseInt(this.maxChars);
          if (maxChars > 0) {
            var charCount = value.length;
            valid = (maxChars + 1) > charCount;

            this._errorMessage = this._errorMessageTemplates.maxCharsHint.replace("{maxChars}", this.maxChars);
          }
        } catch (e) {
          console.log(e);
        }

        return valid;
      },
      // *ij* part of validation behavior API
      // this is a custom validation function which checks the max lines constraint
      _validateMaxLines: function(value) {
        var valid = true;
        try {
          var maxLines = parseInt(this.maxLines);
          if (maxLines > 0) {
            var lineCount = this._getLineCount(value);
            valid = (maxLines + 1) > lineCount;

            this._errorMessage = this._errorMessageTemplates.maxLinesHint.replace("{maxLines}", this.maxLines);
          }
        } catch (e) {
          console.log(e);
        }

        return valid;
      },
      _getLineCount: function (text) {
        var lines = text.split("\n");
        var lineCount = lines.length;
        return lineCount;
      },
      // this function is part of the hint/validation API
      // hint should be displayed when element gains focus
      // behavior can not know when element gained focus
      // but if gived focusable element it can attach to its focus event
      // it should return focusable element if available or null if focusable element doesn't exist
      _getFocusableElement: function () {
        var focusable = this.$.valueProvider;
        return focusable;
      }
    });
  </script>
</dom-module>
