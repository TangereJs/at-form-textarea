<link rel="import" href="../layout/layout.html">
<link rel="import" href="../at-core-theme/at-core-theme.html">
<link rel="import" href="../at-core-resize-sensor/at-core-resize-sensor.html">

<dom-module id="at-form-textarea">
  <style>
    .wrapper {
      position: relative;
    }

    .clear-float {
      clear: both;
    }

    .content-wrapper {}

    .content-wrapper > .label-container {
      margin: 0 8px;
    }

    .content-wrapper > .value-container {}

    .content-wrapper > .hint-container {
      margin: 0 8px;
    }

    .label-container.error > label {
      color: #e41e2b;
    }

    .hint-container.error > p {
      color: #e41e2b;
    }

    #label {
      font-weight: bold;
    }

    #valueProvider {
      min-height: unset;
      max-height: none;
      height: auto;
    }

    .hidden {
      display: none;
    }
  </style>
  <template>
    <at-core-theme></at-core-theme>
    <div class="wrapper">
      <at-core-resize-sensor id="resizeSensor"></at-core-resize-sensor>
      <div class="clear-float"></div>
      <div class="vertical-layout content-wrapper">
        <div id="labelContainer" class="label-container">
          <label id="label">{{label}}</label>
        </div>
        <div class="value-container">
          <div class="ui form">
            <div id="valueProviderWrapper" class="field">
              <textarea id="valueProvider" rows="3"></textarea>
            </div>
          </div>
        </div>
        <div id="hintContainer" class="hint-container">
        </div>
      </div>
    </div>
  </template>
  <script>
    'use strict';
    Polymer({
      is: 'at-form-textarea',
      properties: {
        label: {
          type: String,
          value: ''
        },
        value: {
          type: String,
          value: '',
          notify: true,
          observer: 'valueChanged',
          xtype: 'textarea'
        },
        disabled: {
          type: Boolean,
          value: false,
          observer: 'disabledChanged'
        },
        required: {
          type: Boolean,
          value: false,
          observer: 'requiredChanged'
        },
        valid: {
          type: Boolean,
          value: true,
          notify: true
        },
        /**
         * if maxchars == 0 no check should be done,
         * if != 0 total chars can't be longer then maxchars
         */
        maxChars: {
          type: Number,
          value: 0,
          observer: 'maxCharsChanged'
        },
        /**
         * if maxlines == 0 the textarea should autogrow
         * if maxlines != 0 the textarea should be rendered with the fixed number of lines
         */
        maxLines: {
          type: Number,
          value: 0,
          observer: 'maxLinesChanged'
        },
        hideLabel: {
          type: Boolean,
          value: false,
          observer: 'hideLabelChanged'
        },
        /**
         * Hides the element. When hidden nothing is displayed for the element
         * @property hide
         * @type Boolean
         * @default false
         */
        hide: {
          type: Boolean,
          value: false,
          observer: 'hideChanged'
        }
      },
      $meta: [{
        title: "Textarea",
        type: "string",
        xtype: "textarea"
      }],
      _hintMessages: {
        maxCharsHint: "You can not enter more than {maxChars} characters.",
        maxLinesHint: "You can not enter more than {maxLines} lines of text."
      },
      _scopeCssViaAttr: true,
      _hints: {
        maxChars: "maxChars",
        maxLines: "maxLines"
      },
      hideChanged: function(newValue, oldValue) {
        var wrapper = Polymer.dom(this.root).querySelector('.wrapper');
        this.toggleClass('hidden', newValue, wrapper);
        if (!newValue) {
          this._updateAutoGrow();
        }
      },
      hideLabelChanged: function(newValue, oldValue) {
        this.toggleClass('hidden', newValue, this.$.labelContainer);
      },
      attached: function() {
        var self = this;
        this.$.resizeSensor.addEventListener('resize-sensed', function() {
          self._updateAutoGrow();
        });
      },
      ready: function() {
        var valueProvider = this.$.valueProvider;
        var self = this;
        valueProvider.addEventListener('change', function(event) {
          event.stopPropagation();
          self.value = valueProvider.value;
          self._validate();
        });

        valueProvider.addEventListener('blur', function(event) {
          event.stopPropagation();
          self.value = valueProvider.value;
          self._validate();
        });

        valueProvider.addEventListener('input', function(event) {
          event.stopPropagation();
          self._updateAutoGrow();
          self._updateMaxChars();
          self._updateMaxLines();
        });
      },
      _updateAutoGrow: function() {
        var self = this;
        if (self.maxLines === 0) {
          self.autoGrowHelper();
        }
      },
      _updateMaxChars: function() {
        var
          self = this,
          valueProvider = self.$.valueProvider,
          hint = self.$.hint,
          maxChars = parseInt(self.maxChars);

        if (maxChars > 0) {
          // handle maxChars here
          var valueLength = valueProvider.value.length;
          if (valueLength > maxChars) {
            // valueProvider.value = valueProvider.value.substring(0, maxChars);
            // Polymer.dom(valueProvider).innerHTML = valueProvider.value;
            self._addHint(self._hints.maxChars, self._hintMessages.maxCharsHint.replace('{maxChars}', maxChars));
            self.valid = false;
          } else {
            self.valid = true;
            self._removeHint(self._hints.maxChars);
          }
        } else {
          self.valid = true;
          self._removeHint(self._hints.maxChars);
        }
        self._updateValidUIState(self.valid);
      },
      valueChanged: function(newValue, oldValue) {
        var valueProvider = this.$.valueProvider;
        valueProvider.value = newValue;
        this._updateAutoGrow();
        this._updateMaxChars();
        this._updateMaxLines();
      },
      maxCharsChanged: function(newValue, oldValue) {
        this._updateMaxChars();
      },
      maxLinesChanged: function(newValue, oldValue) {
        var valueProvider = this.$.valueProvider;
        if (Object.prototype.toString.call(newValue) === "[object String]") {
          try {
            this.maxLines = parseInt(newValue);
            return;
          } catch (e) {
            console.log(e);
          }
          return;
        }
        if (newValue === 0) {
          if (valueProvider.scrollHeight > 14) {
            // handle autogrow here
            this.autoGrowHelper();
          } else {}
        }
        // else {
        //   valueProvider.style.height = 'auto';
        //   valueProvider.rows = newValue;
        // }
        this._updateMaxLines();
      },
      _updateMaxLines: function() {
        var valueProvider = this.$.valueProvider;
        try {
          var maxLines = parseInt(this.maxLines);
          if (maxLines > 0) {
            var lines = valueProvider.value.split("\n");
            var lineCount = lines.length;

            if (lineCount > maxLines) {
              if (this._hintExists(this._hints.maxLines)) {
                return;
              }
              this._addHint(this._hints.maxLines, this._hintMessages.maxLinesHint.replace("{maxLines}", this.maxLines));
              this.valid = false;
            } else {
              this._removeHint(this._hints.maxLines);
              this.valid = true;
            }
            this._updateValidUIState(this.valid);
          } else {
            this.valid = true;
            this._removeHint(this._hints.maxLines);
            this._updateValidUIState(this.valid);
          }
        } catch (e) {
          console.log(e);
        }
      },
      _createHint: function(hintId, hintContent) {
        var result = document.createElement('p');
        Polymer.dom(result).setAttribute('id', hintId);
        Polymer.dom(result).innerHTML = hintContent;
        Polymer.dom(result).classList.add('hint');
        return result;
      },
      _addHint: function(hintId, hintContent) {
        var hint = this._createHint(hintId, hintContent);
        var hintContainer = this.$.hintContainer;
        Polymer.dom(hintContainer).appendChild(hint);
      },
      _removeHint: function(hintId) {
        var hintContainer = this.$.hintContainer;
        var hint = Polymer.dom(hintContainer).querySelector('#' + hintId);
        if (hint) {
          Polymer.dom(hintContainer).removeChild(hint);
        }
      },
      _hintExists: function (hintId) {
        var hintContainer = this.$.hintContainer;
        var hint = Polymer.dom(hintContainer).querySelector('#' + hintId);
        return Boolean(hint);
      },
      autoGrowHelper: function() {
        var valueProvider = this.$.valueProvider;
        if (valueProvider.scrollHeight > 0) {
          valueProvider.style.height = 'auto';
          valueProvider.style.height = (valueProvider.scrollHeight + 3) + 'px';
        }
      },
      disabledChanged: function(newValue, oldValue) {
        this.$.valueProvider.disabled = Boolean(newValue);
      },
      requiredChanged: function(newValue, oldValue) {
        this._validate();
      },
      _validate: function() {
        var valueProvider = this.$.valueProvider;
        this.valid = !(this.required && this._isNullOrEmpty(valueProvider.value));
        this._updateValidUIState(this.valid);
      },
      _updateValidUIState: function(isValid) {
        var valueProviderWrapper = this.$.valueProviderWrapper;
        this.toggleClass('error', !isValid, valueProviderWrapper);
        var labelContainer = this.$.labelContainer;
        this.toggleClass('error', !isValid, labelContainer);
        var hintContainer = this.$.hintContainer;
        this.toggleClass('error', !isValid, hintContainer);
      },
      _isNullOrEmpty: function(obj) {
        return obj == null || obj === '';
      }
    });
  </script>
</dom-module>
